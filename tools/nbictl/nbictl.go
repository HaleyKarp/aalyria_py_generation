// Copyright 2023 Aalyria Technologies, Inc., and its affiliates.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package nbictl

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	commonpb "aalyria.com/spacetime/api/common"
	pb "aalyria.com/spacetime/api/nbi/v1alpha"
	resourcespb "aalyria.com/spacetime/api/nbi/v1alpha/resources"
	"github.com/urfave/cli/v2"
	intervalpb "google.golang.org/genproto/googleapis/type/interval"
	"google.golang.org/protobuf/encoding/prototext"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/durationpb"
	"google.golang.org/protobuf/types/known/timestamppb"
)

const (
	confFileName = "config.textproto"

	// modified from
	// https://github.com/urfave/cli/blob/c023d9bc5a3122830c9355a0a8c17137e0c8556f/template.go#L98
	readmeDocTemplate = `{{if gt .SectionNum 0}}% {{ .App.Name }} {{ .SectionNum }}

{{end}}# NAME

{{ .App.Name }}{{ if .App.Usage }} - {{ .App.Usage }}{{ end }}

# SYNOPSIS

{{ if .SynopsisArgs }}` + "```" + `
{{ .App.Name }} {{ range $f := .App.VisibleFlags -}}{{ range $n := $f.Names }}[{{ if len $n | lt 1 }}--{{ else }}-{{ end }}{{ $n }}{{ if $f.TakesValue }}=value{{ end }}] {{ end }}{{ end }}<command> [COMMAND OPTIONS] [ARGUMENTS...]
` + "```" + `
{{ end }}{{ if .GlobalArgs }}
# GLOBAL OPTIONS
{{ range $v := .GlobalArgs }}
{{ $v }}{{ end }}
{{ end }}{{ if .Commands }}# COMMANDS
{{ range $v := .Commands }}
{{ $v }}{{ end }}{{ end }}`
)

var entityTypeList = generateTypeList()

func init() {
	cli.MarkdownDocTemplate = readmeDocTemplate
}

func validateEntityType(_ *cli.Context, t string) error {
	for _, et := range entityTypeList {
		if t == et {
			return nil
		}
	}

	return fmt.Errorf("unknown entity type %q", t)
}

func App() *cli.App {
	return &cli.App{
		Name:        "nbictl",
		Usage:       "Interact with the Spacetime NBI service from the command line.",
		Description: "`nbctl` is a tool that allows you to interact with the Spacetime NBI APIs from the command-line.",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:  "context",
				Usage: "Context (configuration profile) to reference for connection settings.",
			},
		},
		Commands: []*cli.Command{
			{
				Name:     "readme",
				Category: "help",
				Usage:    "Prints the help information as Markdown.",
				Hidden:   true,
				Action: func(appCtx *cli.Context) error {
					md, err := appCtx.App.ToMarkdown()
					if err != nil {
						return err
					}
					fmt.Println(`<!--`)
					fmt.Println("This file is autogenerated! Do not edit by hand!")
					fmt.Println("Run `nbictl readme > README.md` to update it.")
					fmt.Println("-->")
					fmt.Println()

					fmt.Println(md)
					return nil
				},
			},
			{
				Name:     "man",
				Category: "help",
				Usage:    "Prints the help information as a man page.",
				Hidden:   true,
				Action: func(appCtx *cli.Context) error {
					man, err := appCtx.App.ToMan()
					if err != nil {
						return err
					}
					fmt.Println(man)
					return nil
				},
			},
			{
				Name:     "create",
				Category: "entities",
				Usage:    "Create one or more entities described in textproto files.",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:     "files",
						Usage:    "[REQUIRED] Glob of textproto files that represent one or more Entity messages.",
						Aliases:  []string{"f"},
						Required: true,
					},
				},
				Action: Create,
			},
			{
				Name:     "update",
				Category: "entities",
				Usage:    "Updates one or more entities described in textproto files.",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:     "files",
						Usage:    "[REQUIRED] Glob of textproto files that represent one or more Entity messages.",
						Aliases:  []string{"f"},
						Required: true,
					},
				},
				Action: Update,
			},
			{
				Name:     "list",
				Category: "entities",
				Usage:    "Lists all entities of a given type.",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:     "type",
						Usage:    fmt.Sprintf("[REQUIRED] Type of entities to query. Allowed values: [%s]", strings.Join(entityTypeList, ", ")),
						Aliases:  []string{"t"},
						Required: true,
						Action:   validateEntityType,
					},
				},
				Action: List,
			},
			{
				Name:     "delete",
				Category: "entities",
				Usage:    "Deletes the entity with the given type and ID.",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:     "type",
						Usage:    fmt.Sprintf("[REQUIRED] Type of entity to delete. Allowed values: [%s]", strings.Join(entityTypeList, ", ")),
						Aliases:  []string{"t"},
						Required: true,
						Action:   validateEntityType,
					},
					&cli.StringFlag{
						Name:     "id",
						Usage:    "[REQUIRED] ID of entity to delete.",
						Aliases:  []string{},
						Required: true,
					},
					&cli.IntFlag{
						Name:     "timestamp",
						Usage:    "[REQUIRED] Commit timestamp of entity to delete.",
						Aliases:  []string{"commit_time"},
						Required: true,
					},
				},
				Action: Delete,
			},
			{
				Name:        "get-link-budget",
				Usage:       "Gets link budget details",
				Category:    "entities",
				Description: "Gets link budget details for a given signal propagation request between a transmitter and a target platform.",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "input_file",
						Usage: "A path to a textproto file containing a SignalPropagationRequest message. If set, it will be used as the request to the SignalPropagation service. If unset, the request will be built from the other flags.",
					},
					&cli.StringFlag{
						Name:  "tx_platform_id",
						Usage: "The Entity ID of the PlatformDefinition that represents the transmitter.",
					},
					&cli.StringFlag{
						Name:  "tx_transceiver_model_id",
						Usage: "The ID of the transceiver model on the transmitter.",
					},
					&cli.StringFlag{
						Name:  "target_platform_id",
						Usage: "The Entity ID of the PlatformDefinition that represents the target. Leave unset if the antenna is fixed or non-steerable, in which case coverage calculations will be returned.",
					},
					&cli.StringFlag{
						Name:  "target_transceiver_model_id",
						Usage: "The ID of the transceiver model on the target.Leave unset if the antenna is fixed or non-steerable, in which case coverage calculations will be returned.",
					},
					&cli.StringFlag{
						Name:  "band_profile_id",
						Usage: "The Entity ID of the BandProfile used for this link.",
					},
					&cli.TimestampFlag{
						Name:   "analysis_start_timestamp",
						Layout: time.RFC3339,
						Usage:  "An RFC3339 formatted timestamp for the beginning of the interval to evaluate the signal propagation. Defaults to the current local timestamp.",
					},
					&cli.TimestampFlag{
						Name:   "analysis_end_timestamp",
						Layout: time.RFC3339,
						Usage:  "An RFC3339 formatted timestamp for the end of the interval to evaluate the signal propagation. If unset, the signal propagation is evaluated at the instant of the `analysis_start_timestamp.`",
					},
					&cli.DurationFlag{
						Name:        "step_size",
						DefaultText: "1m",
						Usage:       "The analysis step size and the temporal resolution of the response.",
					},
					&cli.DurationFlag{
						Name:        "spatial_propagation_step_size",
						DefaultText: "1m",
						Usage:       "The analysis step size for spatial propagation metrics.",
					},
					&cli.BoolFlag{
						Name:        "explain_inaccessibility",
						DefaultText: "false",
						Usage:       "If true, the server will spend additional computational time determining the specific set of access constraints that were not satisfied and including these reasons in the response.",
					},
					&cli.TimestampFlag{
						Name:        "reference_data_timestamp",
						Layout:      time.RFC3339,
						Usage:       "An RFC3339 formatted timestamp for the instant at which to reference the versions of the platforms. Defaults to `analysis_start_timestamp`.",
						DefaultText: "analysis_start_timestamp",
					},
					&cli.PathFlag{
						Name:        "output_file",
						Usage:       "Path to a textproto file to write the response. If unset, defaults to stdout.",
						DefaultText: "/dev/stdout",
					},
				},
				Action: GetLinkBudget,
			},
			{
				Name:      "generate-keys",
				Category:  "configuration",
				Usage:     "Generate RSA keys to use for authentication with the Spacetime APIs.",
				UsageText: "After creating the Private-Public keypair, you will need to request API access by sharing the `.crt` file (a self-signed x509 certificate containing the public key) with Aalyria to receive the `USER_ID` and a `KEY_ID` needed to complete the nbictl configuration. Only share the public certificate (`.crt`) with Aalyria or third-parties. The private key (`.key`) must be protected and should never be sent by email or communicated to others.",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "dir",
						Usage:       "Directory to store the generated RSA keys in.",
						DefaultText: "~/.config/nbictl/keys",
						Aliases:     []string{"directory"},
					},
					&cli.StringFlag{
						Name:     "org",
						Usage:    "[REQUIRED] Organization of certificate.",
						Aliases:  []string{"organization"},
						Required: true,
					},
					&cli.StringFlag{
						Name:  "country",
						Usage: "Country of certificate.",
					},
					&cli.StringFlag{
						Name:  "state",
						Usage: "State of certificate.",
					},
					&cli.StringFlag{
						Name:  "location",
						Usage: "Location of certificate.",
					},
				},
				Action: GenerateKeys,
			},
			{
				Name:     "set-config",
				Usage:    "Sets or updates a configuration profile that contains NBI connection settings. You can create multiple configs by specifying the name of the configuration using the `--context` flag (defaults to \"DEFAULT\").",
				Category: "configuration",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "priv_key",
						Usage: "Path to the private key to use for authentication.",
					},
					&cli.StringFlag{
						Name:  "key_id",
						Usage: "Key ID associated with the private key provided by Aalyria.",
					},
					&cli.StringFlag{
						Name:  "user_id",
						Usage: "User ID associated with the private key provided by Aalyria.",
					},
					&cli.StringFlag{
						Name:  "url",
						Usage: "URL of the NBI endpoint.",
					},
					&cli.StringFlag{
						Name:  "transport_security",
						Usage: "Transport security to use when connecting to the NBI service. Allowed values: [insecure, system_cert_pool]",
					},
				},
				Action: SetConfig,
			},
		},
	}
}

func Create(appCtx *cli.Context) error {
	files := appCtx.String("files")
	if files == "" {
		return errors.New("--files required")
	}
	ctxName := appCtx.String("context")

	configDir, err := os.UserConfigDir()
	if err != nil {
		return fmt.Errorf("unable to obtain the default config directory: %w", err)
	}
	confPath := filepath.Join(configDir, appCtx.App.Name, confFileName)

	setting, err := GetConfig(ctxName, confPath)
	if err != nil {
		return fmt.Errorf("unable to obtain context information: %w", err)
	}
	conn, err := OpenConnection(appCtx.Context, setting)
	if err != nil {
		return err
	}
	defer conn.Close()

	client := pb.NewNetOpsClient(conn)

	textprotoFiles, err := filepath.Glob(files)
	if err != nil {
		return fmt.Errorf("unable to expand the file path: %w", err)
	} else if len(textprotoFiles) == 0 {
		return fmt.Errorf("no files found under the given file path: %s", files)
	}

	entities := []*pb.Entity{}
	for _, textProtoFile := range textprotoFiles {
		entity := &pb.Entity{}
		if err := readFromFile(textProtoFile, entity); err != nil {
			return fmt.Errorf("error while parsing create entity request for file %s: %w", textProtoFile, err)
		}
		entities = append(entities, entity)
	}

	for idx, entity := range entities {
		entityType := entity.Group.GetType().String()
		createEntityRequest := &pb.CreateEntityRequest{Type: &entityType, Entity: entity}

		res, err := client.CreateEntity(appCtx.Context, createEntityRequest)
		if err != nil {
			return fmt.Errorf("unable to create an entity: %w", err)
		}
		protoMessage, err := prototext.MarshalOptions{Multiline: true}.Marshal(res)
		if err != nil {
			return fmt.Errorf("unable to convert the response into textproto format: %w", err)
		}
		fmt.Println(string(protoMessage))
		fmt.Fprintf(os.Stderr, "entity successfully created!:\nid: %s commit_timestamp: %d type: %v file_location: %s\n",
			*res.Id, *res.CommitTimestamp, res.GetGroup().GetType(), textprotoFiles[idx])
	}
	return nil
}

func Update(appCtx *cli.Context) error {
	files := appCtx.String("files")
	ctxName := appCtx.String("context")

	configDir, err := os.UserConfigDir()
	if err != nil {
		return fmt.Errorf("unable to obtain the default config directory: %w", err)
	}
	confPath := filepath.Join(configDir, appCtx.App.Name, confFileName)

	setting, err := GetConfig(ctxName, confPath)
	if err != nil {
		return fmt.Errorf("unable to obtain context information: %w", err)
	}

	conn, err := OpenConnection(appCtx.Context, setting)
	if err != nil {
		return err
	}
	defer conn.Close()

	client := pb.NewNetOpsClient(conn)

	textprotoFiles, err := filepath.Glob(files)
	if err != nil {
		return fmt.Errorf("unable to expand the file path %w", err)
	} else if len(textprotoFiles) == 0 {
		return fmt.Errorf("no files found under the given file path: %s", files)
	}

	entities := []*pb.Entity{}
	for _, textProtoFile := range textprotoFiles {
		entity := &pb.Entity{}

		if err := readFromFile(textProtoFile, entity); err != nil {
			return fmt.Errorf("error while parsing update entity for file %s: %w", textProtoFile, err)
		}
		entities = append(entities, entity)
	}

	for idx, entity := range entities {
		entityType := entity.Group.GetType().String()
		entityID := entity.GetId()
		updateEntityRequest := &pb.UpdateEntityRequest{Type: &entityType, Id: &entityID, Entity: entity}
		res, err := client.UpdateEntity(appCtx.Context, updateEntityRequest)
		if err != nil {
			return fmt.Errorf("unable to update the entity: %w", err)
		}

		protoMessage, err := prototext.MarshalOptions{Multiline: true}.Marshal(res)
		if err != nil {
			return fmt.Errorf("unable to convert the response into textproto format: %w", err)
		}
		fmt.Println(string(protoMessage))
		fmt.Fprintf(os.Stderr, "update successful:\n id: %s commit_timestamp: %d type: %v file_location: %s\n", *res.Id, *res.CommitTimestamp, res.GetGroup().GetType(), textprotoFiles[idx])
	}

	return nil
}

func Delete(appCtx *cli.Context) error {
	ctxName := appCtx.String("context")

	entityType := appCtx.String("type")
	id := appCtx.String("id")
	commitTime := appCtx.Int64("timestamp")

	configDir, err := os.UserConfigDir()
	if err != nil {
		return fmt.Errorf("unable to obtain the default config directory: %w", err)
	}
	confPath := filepath.Join(configDir, appCtx.App.Name, confFileName)

	setting, err := GetConfig(ctxName, confPath)
	if err != nil {
		return fmt.Errorf("unable to obtain context information: %w", err)
	}

	conn, err := OpenConnection(appCtx.Context, setting)
	if err != nil {
		return err
	}
	defer conn.Close()

	if _, err := pb.NewNetOpsClient(conn).DeleteEntity(appCtx.Context, &pb.DeleteEntityRequest{Type: &entityType, Id: &id, CommitTimestamp: &commitTime}); err != nil {
		return fmt.Errorf("unable to delete the entity: %w", err)
	}
	fmt.Fprintln(os.Stderr, "deletion successful")
	return nil
}

func List(appCtx *cli.Context) error {
	entityType := appCtx.String("type")
	ctxName := appCtx.String("context")

	configDir, err := os.UserConfigDir()
	if err != nil {
		return fmt.Errorf("unable to obtain the default config directory: %w", err)
	}
	confPath := filepath.Join(configDir, appCtx.App.Name, confFileName)

	setting, err := GetConfig(ctxName, confPath)
	if err != nil {
		return fmt.Errorf("unable to obtain context information: %w", err)
	}

	conn, err := OpenConnection(appCtx.Context, setting)
	if err != nil {
		return err
	}

	client := pb.NewNetOpsClient(conn)

	if _, exists := pb.EntityType_value[entityType]; !exists {
		return fmt.Errorf("unknown entity type %q is not one of [%s]", entityType, strings.Join(entityTypeList, ", "))
	}

	res, err := client.ListEntities(appCtx.Context, &pb.ListEntitiesRequest{Type: &entityType})
	if err != nil {
		return fmt.Errorf("unable to list entities: %w", err)
	}
	protoMessage, err := prototext.MarshalOptions{Multiline: true}.Marshal(res)
	if err != nil {
		return fmt.Errorf("unable to convert the response into textproto format: %w", err)
	}
	fmt.Println(string(protoMessage))
	fmt.Fprintf(os.Stderr, "successfully queried a list of entities. number of entities: %d\n", len(res.Entities))
	return nil
}

func GetLinkBudget(appCtx *cli.Context) error {
	ctxName := appCtx.String("context")

	configDir, err := os.UserConfigDir()
	if err != nil {
		return fmt.Errorf("unable to obtain the default config directory: %w", err)
	}
	confPath := filepath.Join(configDir, appCtx.App.Name, confFileName)

	setting, err := GetConfig(ctxName, confPath)
	if err != nil {
		return fmt.Errorf("unable to obtain context information: %w", err)
	}

	conn, err := OpenConnection(appCtx.Context, setting)
	if err != nil {
		return err
	}
	defer conn.Close()
	client := pb.NewSignalPropagationClient(conn)

	spReq := &pb.SignalPropagationRequest{}
	if appCtx.IsSet("input_file") {
		reqPath := appCtx.String("input_file")
		// If the user input a textproto file, use it to build the request.
		req, err := os.ReadFile(reqPath)
		if err != nil {
			return fmt.Errorf("invalid file path: %w", err)
		}

		if err := prototext.Unmarshal(req, spReq); err != nil {
			return fmt.Errorf("reading SignalPropagationRequest from file %s: %w", reqPath, err)
		}
	} else {
		txPlatformID := appCtx.String("tx_platform_id")
		txTransceiverModelID := appCtx.String("tx_transceiver_model_id")
		bandProfileID := appCtx.String("band_profile_id")

		errs := []error{}
		if txPlatformID == "" {
			errs = append(errs, errors.New("--tx_platform_id required"))
		}
		if txTransceiverModelID == "" {
			errs = append(errs, errors.New("--tx_transceiver_model_id required"))
		}
		if bandProfileID == "" {
			// TODO: Output a list of valid band profile IDs.
			errs = append(errs, errors.New("--band_profile_id required"))
		}

		startTime := appCtx.Timestamp("analysis_start_timestamp")
		if startTime == nil {
			// If the user did not specify the start of the analysis interval,
			// it is set to the current local time.
			now := time.Now()
			startTime = &now
		}

		endTime := appCtx.Timestamp("analysis_end_timestamp")
		if endTime == nil {
			// If the user did not provide the end of the analysis interval, it
			// is set to the start time. Therefore, the signal propagation will
			// be evaluated at the instant of the start time.
			endTime = startTime
		}

		refDataTime := appCtx.Timestamp("reference_data_timestamp")
		if refDataTime == nil {
			// If the user did not specify a reference data time, it is set to
			// the start of the analysis interval. Therefore, the version of
			// the entities used in the signal propagation analysis will match
			// the start of the analysis interval.
			refDataTime = startTime
		}

		target := &resourcespb.TransceiverProvider{}
		switch {
		case appCtx.IsSet("target_platform_id") && appCtx.IsSet("target_transceiver_model_id"):
			target = &resourcespb.TransceiverProvider{
				Source: &resourcespb.TransceiverProvider_IdInStore{
					IdInStore: &commonpb.TransceiverModelId{
						PlatformId:         proto.String(appCtx.String("target_platform_id")),
						TransceiverModelId: proto.String(appCtx.String("target_transceiver_model_id")),
					},
				},
			}
		case !appCtx.IsSet("target_platform_id") && !appCtx.IsSet("target_transceiver_model_id"):
			// When the target's platform ID and transceiver model ID are not
			// specified, the target field should be left unset (as opposed to
			// setting it to an empty TransceiverProvider) to model the case of
			// a fixed antenna.
			target = nil
		case !appCtx.IsSet("target_platform_id"):
			errs = append(errs, errors.New("--target_platform_id required"))
		case !appCtx.IsSet("target_transceiver_model_id"):
			errs = append(errs, errors.New("--target_transceiver_model_id required."))
		}

		if err := errors.Join(errs...); err != nil {
			return err
		}

		stepSize := appCtx.Duration("step_size")
		spatialPropagationStepSize := appCtx.Duration("spatial_propagation_step_size")
		explainInaccessibility := appCtx.Bool("explain_inaccessibility")

		spReq = &pb.SignalPropagationRequest{
			TransmitterModel: &resourcespb.TransceiverProvider{
				Source: &resourcespb.TransceiverProvider_IdInStore{
					IdInStore: &commonpb.TransceiverModelId{
						PlatformId:         &txPlatformID,
						TransceiverModelId: &txTransceiverModelID,
					},
				},
			},
			BandProfileId: &bandProfileID,
			Target:        target,
			AnalysisTime: &pb.SignalPropagationRequest_AnalysisInterval{
				AnalysisInterval: &intervalpb.Interval{
					StartTime: timestamppb.New(*startTime),
					EndTime:   timestamppb.New(*endTime),
				},
			},
			StepSize:                   durationpb.New(stepSize),
			SpatialPropagationStepSize: durationpb.New(spatialPropagationStepSize),
			ExplainInaccessibility:     &explainInaccessibility,
			ReferenceDataTime:          timestamppb.New(*refDataTime),
		}
	}

	spRes, err := client.Evaluate(appCtx.Context, spReq)
	if err != nil {
		return fmt.Errorf("SignalPropagation.Evaluate: %w", err)
	}
	spResProto, err := prototext.MarshalOptions{Multiline: true}.Marshal(spRes)
	if err != nil {
		return fmt.Errorf("unable to convert the response into textproto format: %w", err)
	}

	if !appCtx.IsSet("output_file") {
		fmt.Println(string(spResProto))
	} else {
		outPath := appCtx.Path("output_file")
		// Creates the output file, if necessary, with read and write permissions.
		if err := os.WriteFile(outPath, spResProto, 0666); err != nil {
			return fmt.Errorf("writing to output file %s: %w", outPath, err)
		}
	}
	fmt.Fprintln(os.Stderr, "successfully retrieved link budget.")
	return nil
}

func generateTypeList() []string {
	var typeList []string
	for _, val := range pb.EntityType_name {
		if val != "ENTITY_TYPE_UNSPECIFIED" {
			typeList = append(typeList, val)
		}
	}
	sort.Strings(typeList)
	return typeList
}

func readFromFile(filePath string, entity *pb.Entity) error {
	msg, err := os.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("invalid file path: %w", err)
	}

	if err := prototext.Unmarshal(msg, entity); err != nil {
		return fmt.Errorf("invalid file content: %w", err)
	}
	return nil
}
